<?xml version="1.0" encoding="US-ASCII"?>
<!-- this is version 5 of this xml2rfc template -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc8174 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc8446 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY I-D.ietf-tls-esni SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-esni">

]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc category="exp" docName="draft-farrell-tls-wkesni-01" ipr="trust200902" >
  <front>
    <title abbrev="Well-Known URI for ESNI">A well-known URI for publishing ESNIKeys</title>

    <author fullname="Stephen Farrell" initials="S." surname="Farrell">
      <organization>Trinity College Dublin</organization>

      <address>
        <postal>
          <street/>

          <city>Dublin</city>

          <region/>

          <code>2</code>

          <country>Ireland</country>
        </postal>

        <phone>+353-1-896-2354</phone>

        <email>stephen.farrell@cs.tcd.ie</email>
      </address>
    </author>

    <date year="2019"/>

    <area>Security Area</area>

    <workgroup>TLS</workgroup>

    <keyword>TLS</keyword>

    <keyword>ESNI</keyword>

    <abstract>
        <t>We propose use of a well-known URI at which web servers can publish ESNIKeys 
            as a way to help get those published in the DNS.</t> 
    </abstract>
  </front>

  <middle>
    <section title="Introduction">

        <t>Encrypted Server Name Indication (ESNI) 
            <xref target="I-D.ietf-tls-esni"/> for TLS1.3 <xref target="RFC8446"/>
            defines a confidentiality mechanism for server names in TLS.
        That requires publication of an ESNIKEys data structure in the DNS.</t>

        <t>
            Many web servers will have an API that can be used to 
            dynamically update ESNIKeys in the DNS. Some implementations/deployments 
            however, will not, so web server implementers could benefit from a mechanism to use in such cases. 
            We define such a mechanism here. 
            Note that this is not intended for
            universal deployment, but just for cases where the zone file (or 
            equivalent) that
            includes the ESNIKeys RR is on some machine, which we here call a
            "zone factory," to which the web server doesn't have write access. 
        </t>

        <t>
            We propose use of a well-known URI on the web server that 
            allows the zone factory for that web server to poll for changes 
            to ESNIKeys RR values. For example, if a web server generates new 
            ESNIKeys hourly and publishes those at the .well-known URI, its 
            zone factory  server can poll that URI.  When the zone factory sees new 
            values, it can check if those work, and if they do, then update the 
            zone file and re-publish the zone.
        </t>

        <t>[[This idea could: a) wither on the vine, b) be published
            as it's own RFC, or c) end up as a PR for <xref target="I-D.ietf-tls-esni"/>.
            There is no absolute need for this to be in the RFC that
            defines ESNI, so (b) seems feasible it there's enough
            interest, hence this draft.
            The source for this is in https://github.com/sftcd/wkesni/ 
            PRs are welcome there too.]]
        </t>

      </section>

      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in BCP
        14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
        when, they appear in all capitals, as shown here.</t>
      </section>

    <section title="Example Use of .well-known for ESNIKeys">

        <t>An example deployment could be as follows:

           <list style="symbols">
                <t> Web server generates new ESNIKeys hourly at N past 
                    the hour via a cronjob</t>
                <t> ESNIKeys are "current" for an hour, published with
                    a TTL of 1800, and remain usable for 3 hours from the time
                    of generation</t>
                <t> Web server has a set of "hidden" sites - the DNS name
                    for each hidden web site is each here represented
                    as $HIDDEN, which will end up as a realSNI value to be encrypted
                    inside an ESNI extension</t>
                <t> Web server has a "cover" site ($COVER), where
                    $COVER will typically be the DNS name used in the
                    ESNIKeys public_name field for ESNIKeys version 0xff02</t>
                <t> The cronjob creates creates a JSON file for each hidden
                    site at https://$COVER/.well-known/esni/$HIDDEN.json</t>
                <t> Each JSON file contains an array with the ESNIKeys RR
                    values for that particular $HIDDEN as shown in 
                    <xref target="sample-json"/>  -
                the values in <xref target="sample-json"/> with ellipses are the RR values we
                    want to eventually see in the DNS</t>
                <t> On the zone factory, a cronjob runs at N+3 past the
                    hour, it knows all the names involved and checks to see
                    if the content at those well-known URIs has changed or
                    not</t>
                <t> If the content has changed the cronjob attempts to use
                    the ESNIKeys, and for each $HIDDEN where that works, it
                    updates the zone file and re-publishes the zone 
                    containing only the new ESNIKeys RR values</t>
            </list>
        </t>

<figure anchor="sample-json" title="Sample JSON" >
<artwork><![CDATA[
    [
        {
            "ESNIKeys.version": 0xff01,
            "desired-ttl": 1800,
            "ESNIKeys": "/wH5QHc...="
        },
        {
            "ESNIKeys.version": 0xff02,
            "desired-ttl": 1800,
            "ESNIKeys": "FF02897...OA"
        }
    ]
  ]]></artwork>
</figure>

    </section>

<section title="The JSON structure for ESNIKeys">

  <t>[[Since the specifics of the JSON structure in <xref target="sample-json"/> are very 
      likely to change, this is mostly TBD. What is here for now, is what the author
      has currently implemented simply because it worked ok and was easy to do:-)]]</t>

    <t>The JSON file at the well-known URI MUST contain an array
        with one or more elements. Each element of the array
        MUST have these fields:
        <list style="symbols">
            <t>ESNIKeys.version: contains a number with the value of
                the version field of the ESNIKeys. This is needed (today)
                as different versions are published in the DNS differently.
                (Draft-02 used a TXT RR and is still all that is
                usable with some early test deployments,
                draft-03 uses a new RRTYPE from the experimental range.)
            </t>
            <t>desired-ttl: contains a number indicating the TTL that
                the web server would like to see used for this RR.
                The zone factory MUST NOT use a longer TTL.
            </t>
            <t>ESNIKeys: contains the RRVALUE value to be used, either
                as a base64 encoded string (for ESNIKeys.version of 0xff01)
                or as an ASCII-HEX string (for ESNIKeys.version of 0xff02).
            </t>
        </list>
    </t>

    <t>The JSON file contains an array for a couple of reasons:
        <list style="symbols">
            <t>While ESNI is still in draft form, it may be necessary
                to publish different versions of the ESNIKeys structure.
            </t>
            <t>For some deployments, the same $HIDDEN could be accessible,
                using ESNI, via different $COVER (or public_name) web
                servers.
            </t>
            <t>As ESNIKeys is (regrettably:-) an extensible structure,
                it may be necessary to publish different ESNIKeys 
                values to get best interoperability.
            </t> 
        </list>
    </t>

    <t>The zone factory SHOULD check that the presented ESNIKeys
        values work with the $HIDDEN server before publication.
        A "special" TLS client may be needed for this check,
        that does not require the ESNIKeys value to have 
        already been published in the DNS.
        [[I guess that could call for the zone factory to know
        of a "safe" URL on $HIDDEN to use, or maybe it could
        use HTTP HEAD? Figuring that out is TBD.]]
    </t>

    <t>The zone factory SHOULD publish all the ESNIKeys values
        that are presented in the JSON file, and that pass
        the check above.</t>

    <t>The zone factory SHOULD only publish ESNIKeys values
        that are in the latest version of the JSON file.
        This leaves the control of "expiry" with the
        web server, so long as the ESNIKeys presented
        actually work. [[An alternative could be to 
        have the new values just be appended to the zone,
        but that'd require some form of "notAfter" value
        in the JSON file which seems unnecessary and more 
        complex.]]
    </t>

    <t>From the point of view of the zone factory, 
        the KeyShareEntry values within each element of the
        JSON array are entirely independent. The zone
        factory MUST NOT assume that there is any 
        specific relationship between the ESNIKeys
        values in one JSON structure, nor between the set of
        JSON structures for the set of $HIDDEN sites
        that share a $COVER.
    </t> 

    <t>The ESNI specification 
        <xref target="I-D.ietf-tls-esni"/> defines
        how and where the ESNIKeys RR for $HIDDEN
        needs to be published in the DNS.
    </t>

<t>A possibly interesting (unintended) consequence of this
   design is that once a
  TLS client has first gotten ESNIKeys from the DNS for
  $HIDDEN with the draft-03 ESNIKeys structure containing
  the public_name field, the TLS client would know both
  $COVER and $HIDDEN and so could later probe for this
  .well-known as an alternative to doing so via DoT/DoH.
  Probably not something a web browser might do, but
  could be fun for other applications maybe.
  </t>

</section>


    <section title="Security Considerations">
        <t>This document defines another way to publish ESNIKeys. If the wrong
            keys were read from here and published in the DNS, then clients
            using ESNI would do the wrong thing. So: Don't do that:-)</t>

    </section>

    <section title="Acknowledgements">
        <t>Thanks to Niall O'Reilly for a quick review.</t>
    </section>

    <section title="IANA Considerations">
        <t>[[TBD: IANA registration of a .well-known. Also TBD - how to handle I18N for
            $COVER and $HIDDEN within such a URL.]]</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.8446'?>
      &I-D.ietf-tls-esni;

    </references>

    <!--
    <references title="Informative References">
    </references>
    -->

    <section title="Change Log ">
      <t>[[RFC editor: please remove this before publication.]]</t>

      <t>Nothing yet.</t>
    </section>
  </back>
</rfc>
