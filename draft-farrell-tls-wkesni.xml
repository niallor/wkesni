<?xml version="1.0" encoding="US-ASCII"?>
<!-- this is version 5 of this xml2rfc template -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc8174 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY rfc8446 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.8446.xml">
<!ENTITY rfc8615 SYSTEM "https://xml.resource.org/public/rfc/bibxml/reference.RFC.8615.xml">
<!ENTITY I-D.ietf-tls-esni SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-esni">
<!ENTITY I-D.ietf-dnsop-svcb-https SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-dnsop-svcb-https">

]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc category="exp" docName="draft-farrell-tls-wkesni-03" ipr="trust200902" >
  <front>
    <title abbrev="Well-Known URI for ECH">A well-known URI for publishing ECHConfigList values.</title>

    <author fullname="Stephen Farrell" initials="S." surname="Farrell">
      <organization>Trinity College Dublin</organization>
      <address>
        <postal>
          <street/>
          <city>Dublin</city>
          <region/>
          <code>2</code>
          <country>Ireland</country>
        </postal>
        <phone>+353-1-896-2354</phone>
        <email>stephen.farrell@cs.tcd.ie</email>
      </address>
    </author>

    <author initials="R." surname="Salz" fullname="Rich Salz">
        <organization showOnFrontPage="true">Akamai Technologies</organization>
        <address>
            <email>rsalz@akamai.com</email>
        </address>
    </author>

    <author initials="B." surname="Schwartz" fullname="Benjamin Schwartz">
      <organization>Google LLC</organization>
      <address>
        <email>bemasc@google.com</email>
      </address>
    </author>

    <date year="2022"/>

    <area>Security Area</area>

    <workgroup>TLS</workgroup>

    <keyword>TLS</keyword>

    <keyword>ECH</keyword>

    <abstract>
        <t>We propose use of a well-known URI at which web servers can publish ECHConfigList values
            as a way to help get those published in the DNS.</t> 
    </abstract>
  </front>

  <middle>
    <section title="Introduction">

        <t>Encrypted ClientHello (ECH) 
            <xref target="I-D.ietf-tls-esni"/> for TLS1.3 <xref target="RFC8446"/>
            defines a confidentiality mechanism for server names and other ClientHello content in TLS.
            For many applications, that requires publication of ECHConflgList data structures in the DNS.
            An ECHConfigList structure contains a list of ECHConfig values. Each
            ECHConfig value contains the public component of a key pair
            that will typically be periodically (re-)generated by a web server.
            Many web infrastructures will have an API that can be used to 
            dynamically update the DNS RR values containing ECHConfigList values. 
            Some deployments however, will not, so web deployments could 
            benefit from a mechanism to use in such cases. 
        </t>

        <t>
            We define such a mechanism here. Note that this is not intended for
            universal deployment, but rather for cases where the web server
            doesn't have write access to the relevant zone file (or 
            equivalent). That zone file will eventually include an HTTPS or SVCB 
            RR <xref target="I-D.ietf-dnsop-svcb-https"/> containing an ECHConfigList. 
        </t>

        <t>
            We use the term "zone factory" for the entity that does have write
            access to the zone file. We assume the zone factory (ZF) can also 
            make HTTPS requests to the web server with the ECH keys.
        </t>

        <t>
            We propose use of a well-known URI <xref target="RFC8615"/> on the web server that 
            allows ZF to poll for changes to ECHConfigList values. For example, if a web server 
            generates new ECHConfigList values hourly and publishes those at the well-known URI, 
            ZF can poll that URI.  When ZF sees new values, it can check if those work, and if 
            they do, then update the zone file and re-publish the zone.
        </t>

        <t>[[The source for this is in https://github.com/sftcd/wkesni/ 
            PRs are welcome there too.]]
        </t>

      </section>

      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in BCP
        14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
        when, they appear in all capitals, as shown here.</t>
      </section>

    <section title="Example use of the well-known URI for ECH">

        <t>An example deployment could be as follows:

           <list style="symbols">
                <t> Web server generates new ECHConfigList values hourly at N past 
                    the hour via a cronjob</t>
                <t> ECHConfigList values are "current" for an hour, published with
                    a TTL of 1800, and remain usable for 3 hours from the time
                    of generation</t>
                <t> Web server has a set of "backend" sites - the DNS name
                    for each such site is here represented as $BACKEND, which 
                    will end up as an SNI value to be encrypted
                    inside an ECH extension</t>
                <t> Web server has a "front-end" site ($FRONT), where
                    $FRONT will typically be the DNS name used in the
                    ECHConfigList public_name field for ECHConfig version 0xff0d</t>
                <t> A cronjob creates creates a JSON file for each backend
                    site at https://$FRONT/.well-known/ech/$BACKEND.json</t>
                <t> Each JSON file contains an array with the ECHConfigList values
                    values for that particular $BACKEND as shown in 
                <xref target="sample-json"/>  - the values in 
                <xref target="sample-json"/> with ellipses are the values we
                    want to eventually see in the DNS</t>
                <t> On the zone factory, a cronjob runs at N+3 past the
                    hour, it knows all the names involved and checks to see
                    if the content at those well-known URIs has changed or
                    not</t>
                <t> If the content has changed the cronjob attempts to use
                    the ECHConfigList values, and for each $BACKEND where that works, it
                    updates the zone file and re-publishes the zone 
                    containing only the new ECHConfigList values</t>
            </list>
        </t>

    </section>

    <section title="The ech well-known URI">

         <t>When a web server ($FRONT) wants to publish ECHConfigList information 
             for a backend site ($BACKEND) then it provides the JSON content
             defined in <xref target="jsonstr"/> at:
            https://$FRONT/.well-known/ech/$BACKEND.json
        </t>

        <t>The well-known URI defined here MUST be an https URL and therefore the
            zone factory verifies the correct $FRONT is being accessed. If
            there is any failure in accessing the well-known URI, then the
            zone factory MUST NOT modify the zone. </t> 

    </section>


<section anchor="jsonstr" title="The JSON structure for ECHConfigList values">

  <t>[[Since the specifics of the JSON structure in <xref target="sample-json"/> are very 
      likely to change, this is mostly TBD. What is here for now, is what the author
      has currently implemented simply because it worked ok and was easy to do:-)
    One issue raised as a result of the dispatch presentation
    is whether or not anything beyond the ECHConfigList might make
    sense to represent in the JSON response. One example could be
    the inner ClientHello ALPN extension, if that might somehow be
    useful to the TLS cilent (which really should know in that case).
    The scope in that respect and the correct level of generality
        to cover here is something to consider as this evolves.]]</t>

<figure anchor="sample-json" title="Sample JSON" >
<artwork><![CDATA[
    [
        {
            "desired-ttl": 1800,
            "ports": [ 443, 8413 ],
            "echconfiglist": "AD7+DQA65wAgAC..AA=="
        },
        {
            "desired-ttl": 1800,
            "ports": [ 443, 8413 ],
            "echconfiglist": "AD7+DQA65wAgAC..AA=="
        }
    ]
  ]]></artwork>
</figure>

    <t>The JSON file at the well-known URI MUST contain an array
        with one or more elements. Each element of the array
        MUST have these fields:
        <list style="symbols">
            <t>desired-ttl: contains a number indicating the TTL that
                the web server would like to see used for this RR.
                The zone factory MUST NOT use a longer TTL.
            </t>
            <t>ports: this has a list of the TCP ports on which the web server
            with the relevant key pair will listen (needed to produce
            the correct zone file). </t>
            <t>ECHConfigList: contains the value to be used
                as a base64 encoded string.
            </t>
        </list>
    </t>

    <t>The JSON file contains an array for a couple of reasons:
        <list style="symbols">
            <t>As TLS authentication doesn't really distinguish ports, 
            servers on the same host could in any case cheat on one
                another, so we may as well just read one JSON file per name.</t>
            <t>Different ports could map to different sets of ECHConfig values</t>
            <t>As ECHConfigList is (regrettably:-) an extensible structure,
                it may be necessary to publish different ECHConfigList 
                values to get best interoperability.
            </t> 
        </list>
    </t>

</section>

<section title="Zone factory behaviour">

    <t>The zone factory SHOULD check that the presented ECHConfigList
        values work with the $BACKEND server before publication.
        A "special" TLS client may be needed for this check,
        that does not require the ECHConfigList value to have 
        already been published in the DNS.
        [[I guess that calls for the zone factory to know
        of a "safe" URL on $BACKEND to try, or maybe it could
        use HTTP HEAD? Figuring that out is TBD. The ZF could also
        try a GREASEd ECH and see if the retry-configs it gets back
        is one of the ECHConfig values in the ECHConfigList.]]
    </t>

    <t>A careful zone factory could explode the ECHConfigList value
       presented into "singleton" values with one public key in each
       and test each for each port claimed.</t>

    <t>The zone factory SHOULD publish all the ECHConfigList values
        that are presented in the JSON file, and that pass
        the check above.</t>

    <t>The zone factory SHOULD only publish ECHConfigList values
        that are in the latest version of the JSON file.
        This leaves the control of "expiry" with the
        web server, so long as the ECHConfigList values presented
        actually work. [[An alternative could be to 
        have the new values just be appended to the zone,
        but that'd require some form of "notAfter" value
        in the JSON file which seems unnecessary and more 
        complex.]]
    </t>

    <t>The SCVB and HTTPS RR specification <xref target="I-D.ietf-dnsop-svcb-https"/> 
        defines how and where the ECHConfigList values for $BACKEND
        needs to be published in the DNS. The zone factory is 
        assumed to be in control of how ECHConfigList values are
        included in such RRs.
    </t>

<t>A possibly interesting (unintended) consequence of this
   design is that once a
  TLS client has first gotten an ECHConfigList from the DNS for
  $BACKEND with the ECHConfigList structure containing
  the public_name field, the TLS client would know both
  $FRONT and $BACKEND and so could later probe for this
  .well-known as an alternative to doing so via DoT/DoH.
  Probably not something a web browser might do, but
  could be fun for other applications maybe.
  </t>

  <t>[[The extent to which retry-configs could be used for
      a similar purpose might be worth considering. But the
      JSON stuff here may still be needed if implementations
      (such as mine:-) tend to only return one ECHConfig in
      retry-configs.]]</t>

</section>


    <section title="Security Considerations">
        <t>This document defines another way to publish ECHConfigList values. If the wrong
            keys were read from here and published in the DNS, then clients
            using ECH would do the wrong thing, likely resulting in 
            denial of service, or a privacy leak, or worse, when TLS clients attempt to use ECH with
            a backend web site. So: Don't do that:-)</t>

    </section>

    <section title="Acknowledgements">
        <t>Thanks to Niall O'Reilly for a quick review of -00.</t>
    </section>

    <section title="IANA Considerations">
        <t>[[TBD: IANA registration of a .well-known. Also TBD - how to handle I18N for
            $FRONT and $BACKEND within such a URL.]]</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.8446'?>
      <?rfc include='reference.RFC.8615'?>
      &I-D.ietf-tls-esni;
      &I-D.ietf-dnsop-svcb-https;

    </references>

    <!--
    <references title="Informative References">
    </references>
    -->

    <section title="Change Log ">
      <t>[[RFC editor: please remove this before publication.]]</t>

      <t>From -02 to -03:
          <list style="symbols">
              <t>noted scope issue</t>
          </list>
      </t>

      <t>From -01 to -02:
          <list style="symbols">
              <t>General changes from ESNI to ECH.</t>
          </list>
      </t>

      <t>From -00 to -01:
          <list style="symbols">
              <t>Re-structured a bit after re-reading rfc8615</t>
          </list>
      </t>

    </section>
  </back>
</rfc>
